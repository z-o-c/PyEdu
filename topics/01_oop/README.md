# Объектно-ориентированное программирование (ООП)

**Почему важно**: Вы уже используете типы данных, но не создавали свои классы. ООП - фундамент для больших проектов.

**Что изучать**:
- Классы и объекты
- Инкапсуляция (приватные/публичные атрибуты)
- Наследование
- Полиморфизм
- Методы классов и статические методы
- Специальные методы (`__init__`, `__str__`, `__repr__`, `__len__`, etc.)
- Дескрипторы и свойства (properties)

**Материалы**:
- **Официальная документация**: https://docs.python.org/3/tutorial/classes.html

---

## Задача 1.1: Класс для работы с матрицами

**Описание**: Создать класс `Matrix` для работы с матрицами с поддержкой основных операций.

**Технические требования**:
- Класс должен хранить матрицу в виде списка списков в атрибуте `data`
- Конструктор принимает список списков или создает матрицу заданного размера
- Методы: `__add__`, `__sub__`, `__mul__` (умножение на число и матричное умножение)
- Методы: `__str__`, `__repr__`, `__eq__`
- Метод `transpose()` для транспонирования
- Метод `determinant()` для вычисления определителя (для квадратных матриц)

**Подробные инструкции по реализации методов**:

### `__init__(self, matrix)`
- Сохраняет переданную матрицу (список списков) в атрибуте `self.data`
- Пример: `Matrix([[1, 2], [3, 4]])` → `self.data = [[1, 2], [3, 4]]`

### `__str__(self) -> str`
- Возвращает строковое представление матрицы в формате списка списков
- Формат: точно такой же, как у Python списка - `"[[1, 2], [3, 4]]"`
- Используется функцией `str()` и при выводе через `print()`

### `__repr__(self) -> str`
- Возвращает строку, которую можно использовать для воссоздания объекта
- Рекомендуемый формат: `"Matrix([[1, 2], [3, 4]])"`
- Используется при выводе в интерактивном режиме и `repr()`

### `__add__(self, other) -> Matrix`
- Реализует операцию сложения матриц: `matrix1 + matrix2`
- **Логика**: поэлементное сложение двух матриц одинакового размера
- Формула: `result[i][j] = self.data[i][j] + other.data[i][j]`
- Возвращает новый объект `Matrix` с результатом
- Матрицы должны иметь одинаковые размеры (rows и cols)
- Пример: `[[1, 2], [3, 4]] + [[5, 6], [7, 8]] = [[6, 8], [10, 12]]`

### `__sub__(self, other) -> Matrix`
- Реализует операцию вычитания матриц: `matrix1 - matrix2`
- **Логика**: поэлементное вычитание двух матриц одинакового размера
- Формула: `result[i][j] = self.data[i][j] - other.data[i][j]`
- Возвращает новый объект `Matrix` с результатом
- Матрицы должны иметь одинаковые размеры
- Пример: `[[1, 2], [3, 4]] - [[5, 6], [7, 8]] = [[-4, -4], [-4, -4]]`

### `__mul__(self, other) -> Matrix`
- Реализует операцию умножения: `matrix * number` или `matrix * matrix`
- **Важно**: должен работать с двумя типами операндов:
  1. **Умножение на число** (`int` или `float`):
     - Умножает каждый элемент матрицы на число
     - Формула: `result[i][j] = self.data[i][j] * other`
     - Пример: `[[1, 2], [3, 4]] * 2 = [[2, 4], [6, 8]]`
  2. **Матричное умножение** (если `other` - объект `Matrix`):
     - Классическое матричное умножение
     - Формула: `result[i][j] = sum(self.data[i][k] * other.data[k][j] for k in range(кол-во столбцов в self))`
     - Количество столбцов первой матрицы должно равняться количеству строк второй
     - Пример: `[[1, 2], [3, 4]] * [[5, 6], [7, 8]] = [[19, 22], [43, 50]]`
- Определяйте тип `other` через `isinstance(other, (int, float))` или `isinstance(other, Matrix)`
- Возвращает новый объект `Matrix` с результатом

### `__eq__(self, other) -> bool`
- Реализует операцию сравнения: `matrix1 == matrix2`
- **Логика**: две матрицы равны, если они имеют одинаковые размеры и все элементы совпадают
- Сравнивает `self.data` с `other.data` поэлементно
- Возвращает `True` если матрицы равны, `False` в противном случае
- Пример: `Matrix([[1, 2], [3, 4]]) == Matrix([[1, 2], [3, 4]])` → `True`

### `transpose(self) -> Matrix`
- Возвращает транспонированную матрицу (строки становятся столбцами).
- Размер `m×n` превращается в `n×m`.
- Исходную матрицу не изменяет — возвращает новый объект `Matrix`.
- Пример: `Matrix([[1, 2, 3], [4, 5, 6]]).transpose().data == [[1, 4], [2, 5], [3, 6]]`.

### `determinant(self) -> int | float`
- Возвращает определитель квадратной матрицы.
- Допустимо только для квадратных матриц `n×n`; иначе — `ValueError`.
- База: для `1×1` — `a`; для `2×2` — `ad - bc`.
- Пример: `Matrix([[1, 2], [3, 4]]).determinant() == -2`.

**Тест-кейсы**:
```python
# Тест 1: Создание матрицы
m1 = Matrix([[1, 2], [3, 4]])
assert str(m1) == "[[1, 2], [3, 4]]"

# Тест 2: Сложение матриц
m2 = Matrix([[5, 6], [7, 8]])
m3 = m1 + m2
assert m3.data == [[6, 8], [10, 12]]

# Тест 3: Умножение на число
m4 = m1 * 2
assert m4.data == [[2, 4], [6, 8]]

# Тест 4: Матричное умножение
m5 = Matrix([[1, 2], [3, 4]])
m6 = Matrix([[5, 6], [7, 8]])
m7 = m5 * m6
assert m7.data == [[19, 22], [43, 50]]

# Тест 5: Транспонирование
m8 = Matrix([[1, 2, 3], [4, 5, 6]])
m9 = m8.transpose()
assert m9.data == [[1, 4], [2, 5], [3, 6]]

# Тест 6: Определитель
m10 = Matrix([[1, 2], [3, 4]])
assert m10.determinant() == -2

# Тест 7: Сравнение матриц
m11 = Matrix([[1, 2], [3, 4]])
assert m1 == m11

# Тест 8: __str__ - проверка формата вывода
m12 = Matrix([[1, 2, 3], [4, 5, 6]])
assert str(m12) == "[[1, 2, 3], [4, 5, 6]]"
assert str(Matrix([[1]])) == "[[1]]"

# Тест 9: __repr__ - проверка формата представления
m13 = Matrix([[1, 2], [3, 4]])
assert "Matrix" in repr(m13)
assert "[[1, 2], [3, 4]]" in repr(m13)

# Тест 10: __add__ - сложение разных размеров (дополнительно)
m14 = Matrix([[1, 2, 3], [4, 5, 6]])
m15 = Matrix([[7, 8, 9], [10, 11, 12]])
m16 = m14 + m15
assert m16.data == [[8, 10, 12], [14, 16, 18]]

# Тест 11: __sub__ - вычитание матриц
m17 = Matrix([[10, 20], [30, 40]])
m18 = Matrix([[1, 2], [3, 4]])
m19 = m17 - m18
assert m19.data == [[9, 18], [27, 36]]
assert (m1 - m1).data == [[0, 0], [0, 0]]  # Вычитание самой себя = нулевая матрица

# Тест 12: __mul__ - умножение на число (дополнительные случаи)
m20 = Matrix([[1, 2], [3, 4]])
assert (m20 * 0).data == [[0, 0], [0, 0]]  # Умножение на ноль
assert (m20 * -1).data == [[-1, -2], [-3, -4]]  # Умножение на отрицательное число
assert (m20 * 0.5).data == [[0.5, 1.0], [1.5, 2.0]]  # Умножение на float

# Тест 13: __mul__ - матричное умножение (разные размеры)
m21 = Matrix([[1, 2], [3, 4], [5, 6]])  # 3x2
m22 = Matrix([[1, 2, 3], [4, 5, 6]])    # 2x3
m23 = m21 * m22  # Результат должен быть 3x3
assert m23.data == [[9, 12, 15], [19, 26, 33], [29, 40, 51]]

# Тест 14: __eq__ - проверка неравенства
m24 = Matrix([[1, 2], [3, 4]])
m25 = Matrix([[1, 2], [3, 5]])  # Один элемент отличается
assert m24 != m25
m26 = Matrix([[1, 2]])  # Разные размеры
assert m24 != m26

# Тест 15: Комбинация операций
m27 = Matrix([[1, 1], [1, 1]])
m28 = Matrix([[2, 2], [2, 2]])
result = (m27 * 3) + m28  # ([[3, 3], [3, 3]] + [[2, 2], [2, 2]])
assert result.data == [[5, 5], [5, 5]]
```

**Выходной результат**:
- Файл `matrix.py` с классом `Matrix`
- Все тест-кейсы должны проходить успешно
- Код должен содержать docstrings для всех методов

---

## Задача 1.2: Иерархия классов для анализа текста

**Описание**: Создать иерархию классов для анализа текста с использованием наследования и полиморфизма.

**Технические требования**:
- Базовый класс `TextAnalyzer` с методом `analyze(text: str) -> dict`
- Класс `WordFrequencyAnalyzer(TextAnalyzer)` - подсчет частоты слов
- Класс `CharacterFrequencyAnalyzer(TextAnalyzer)` - подсчет частоты символов
- Класс `SentenceAnalyzer(TextAnalyzer)` - анализ предложений (количество, средняя длина)
- Все классы должны иметь метод `analyze()` с разной реализацией (полиморфизм)

**Тест-кейсы**:
```python
# Тест 1: Анализ частоты слов
text = "Python is great. Python is powerful. Python is easy."
analyzer1 = WordFrequencyAnalyzer()
result1 = analyzer1.analyze(text)
assert result1['python'] == 3
assert result1['is'] == 3
assert result1['great'] == 1

# Тест 2: Анализ частоты символов
analyzer2 = CharacterFrequencyAnalyzer()
result2 = analyzer2.analyze(text)
assert result2['p'] > 0
assert result2[' '] > 0  # пробелы

# Тест 3: Анализ предложений
analyzer3 = SentenceAnalyzer()
result3 = analyzer3.analyze(text)
assert result3['sentence_count'] == 3
assert result3['avg_sentence_length'] > 0

# Тест 4: Полиморфизм - работа через базовый класс
analyzers = [WordFrequencyAnalyzer(), CharacterFrequencyAnalyzer(), SentenceAnalyzer()]
results = [a.analyze(text) for a in analyzers]
assert len(results) == 3
assert all(isinstance(r, dict) for r in results)
```

**Выходной результат**:
- Файл `text_analyzers.py` с классами
- Все тест-кейсы должны проходить
- Демонстрация полиморфизма в отдельном файле `demo.py`

---

